/*
  Buttercup compiler - Common Intermediate Language (CIL) code generator.
  Copyright (C) 2013 Ariel Ortiz, ITESM CEM
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;

namespace INT64 {

    class CILGenerator {

        //SymbolTable table;

        int labelCounter = 0;
        //int modo = 0;
        string currentFunc = "";
        public SymbolTable funcs;
        public List<string> global_vars;
        public Dictionary<string,List<string>> localvars;
        public Dictionary<string,List<string>> args = new Dictionary<string,List<string>>();
        private Stack<string> lastLabelsStack = new Stack<string>();
        private Stack<string> firstLabelsLoopStack = new Stack<string>();
        private Stack<string> lastLabelsLoopStack = new Stack<string>();
        private Stack<string> LabelsLoopStack = new Stack<string>();
        public List<string> apifuncs = new List<string>();

        //-----------------------------------------------------------
        string GenerateLabel() {
            return String.Format("${0:000000}", labelCounter++);
        } 
        
        string VisitChildren(Node node, int modo) {
            var str = "";
            foreach (var n in node) {
                str = str + Visit((dynamic) n, modo);
            }
            return str;
        }

        //-----------------------------------------------------------
        static readonly IDictionary<Type, string> CILTypes =
            new Dictionary<Type, string>() {
                { Type.BOOL, "bool" },
                { Type.INT, "int" },
                { Type.VOID, "void"}
            };
     
        public CILGenerator(SymbolTable funcs,Dictionary<string,List<string>> localvars,List<string> global_vars) {
              this.funcs = funcs;
              this.localvars = localvars;
              this.global_vars = global_vars;
        }

       public string Visit(Program_ node) {
            Console.WriteLine("aqui1");
           apifuncs.Add("Printc");
           apifuncs.Add("Printi");
           apifuncs.Add("Prints");
           apifuncs.Add("Println");
           apifuncs.Add("Peadi");
           apifuncs.Add("Reads");
           apifuncs.Add("New");
           apifuncs.Add("Size");
           apifuncs.Add("Add");
           apifuncs.Add("Get");
           apifuncs.Add("Set");
           var str = "";
           str = str + Visit((dynamic) node[0],0);
            return "// Code generated by the buttercup compiler.\n\n" 
                + ".assembly 'Int64' {}\n\n"
                + ".assembly extern 'int64lib' {}\n\n"
                + ".class public 'program' extends " 
                + "['mscorlib']'System'.'Object' {\n" 
                //+ "\t.method public static void 'start'() {\n" 
                //+ "\t\t.entrypoint\n"
              //  + Visit((dynamic) node[0],0)
                + str
                + "}\n"
              //    + Visit((dynamic) node[1])
                ;
        }
        
    //def_list
        public string Visit(Def_list_ node, int modo) {
             Console.WriteLine("aqui2");
            var str = "";
            foreach (var global in global_vars) {
                str = str + "\t.field  public static  int64 '"+ global+"'\n";
            }   
            foreach (var n in node) {
                    str = str  + Visit((dynamic) n, 0);
            }
            return str;
        }
    // modo sirve para saber el scope en el que se llama esta funcion
    // 1 para ser llamada con variables globales
    // 2 para argumentos de una funcion
        public string Visit(Var_ node, int modo){
              Console.WriteLine("aqui2");
            return null;
        }
    
        public string Visit(Fun_ node, int modo){
              Console.WriteLine("aqui3");
            if(modo == 1 || modo == 0){
                this.currentFunc = node.AnchorToken.lexeme;
                var str = "";
                if (currentFunc == "main"){
                    str = str + "\t.method public static void  '"+node.AnchorToken.lexeme+"'(";
                }
                else{
                    str = str + "\t.method public static int64 '"+node.AnchorToken.lexeme+"'(";
                }
                int i = 0;
                if(node[i].GetType() == typeof(Id_list_)){
                    str = str + Visit((dynamic) node[i],0);
                    i = i + 1;
                }
                str = str + ") {\n";
                if (currentFunc == "main"){
                    str = str +"\t\t.entrypoint\n";
                }
                if(node[i].GetType() == typeof(Var_def_list_)){
                    str = str + Visit((dynamic) node[i],1);
                    i = i + 1;
                }
                if(node[i].GetType() ==  typeof(Stmt_list_)){
                    str = str + Visit((dynamic) node[i],0);
                    i = i + 1;
                }
                str = str + "\t\tret\n\t}\n";
                return str;
            }
            else if (modo == 2){
               var str = "";
                Console.WriteLine("aqui55553");
                var str2 = "";
                var i = 0;
                
                 Console.WriteLine(node.AnchorToken.lexeme+"   klkk");
                while (i<funcs[node.AnchorToken.lexeme]){
                    str2= str2+"int64";
                    if(funcs[node.AnchorToken.lexeme] > 1 && funcs[node.AnchorToken.lexeme] != i + 1 ){
                        str2 = str2 +",";
                    }
                    i = i + 1;
                }
                foreach (var n in node) {
                    str = str  + Visit((dynamic) n, 4)+" ";
                   
                }
                if(apifuncs.Contains(node.AnchorToken.lexeme)){
                    str = str + "\t\tcall int64 class ['int64lib']'Int64'.'Utils'::'"+node.AnchorToken.lexeme+"'("+str2+")\n"+"\t\tpop\n";
                }
                else{
                    str = str + "\t\tcall int64 class 'program'::'"+node.AnchorToken.lexeme +"'("+str2+")\n"+"\t\tpop\n";
                }
                return str;
            }
            return "Hola";
        }
        public string Visit(Id_list_ node, int modo){
              Console.WriteLine("aqui4");
           //modo 0 son argumentos de funcion
           var str = "";
           if(modo == 0){
               var i = 0;
               args[currentFunc] = new List<String>();
               foreach (var n in node) {
                    str = str  +"int64 "+ Visit((dynamic) n, modo)+" ";
                    try
                    {
                        Visit((dynamic) node[i+1],modo);
                        str = str  + ",";
                    }
                    catch(System.ArgumentOutOfRangeException e){}
                     Console.WriteLine(Visit((dynamic) n,modo));
                     Console.WriteLine(currentFunc);
                    args[currentFunc].Add(Visit((dynamic) n,modo));
                    var array = "";

                     Console.WriteLine(args[currentFunc].ElementAt(0)+"djnjcnbfbv");
                    i = i + 1;
                }
           }
         return str;
        }
    
        public string Visit(Id_ node,int modo){
              Console.WriteLine("aqui5");
            var str = "";
            if(modo == 0){
                 Console.WriteLine(node.AnchorToken.lexeme);
                str += String.Format("'{0}'", node.AnchorToken.lexeme);
            }
            if(modo == 1){
                 Console.WriteLine("aqui555");
                str = String.Format("'{0}'", node.AnchorToken.lexeme);
            }
            if(modo == 2){
                 Console.WriteLine("aqui5555");
                // si se hace asi esto aqui tengo que checar  
               //var a = Visit((dynamic) node[0], modo);
               // str = str +" ldc.i8 "+ a +"\n";
                 Console.WriteLine(currentFunc+ "en otro");
                var argument = "'"+(node.AnchorToken.lexeme)+"'";
                 Console.WriteLine(argument+"verdadero??");
                 //Console.WriteLine(args[currentFunc][0]+"nnlk0");
                 //Console.WriteLine(args[currentFunc][1]+"nnlk1");
                 var boolean = false;
                if(args.ContainsKey(currentFunc)){
                    if(args[currentFunc].Contains(argument)){
                        boolean = true;
                    }
                }
                if(boolean){
                     Console.WriteLine("aqui5558");
                     str += String.Format(Visit((dynamic) node[0], 2));
                     str += String.Format("\t\tstarg '{0}'\n", node.AnchorToken.lexeme);
                }
                else if(global_vars.Contains(node.AnchorToken.lexeme)){
                     Console.WriteLine("aqui5557");
                     try{
                        str = str + Visit((dynamic) node[0], 2)+"\n";
                        str += String.Format("\t\tstsfld int64 'program'::'{0}'\n", node.AnchorToken.lexeme);
                     }
                     catch(System.ArgumentOutOfRangeException m){}
                     //str += String.Format("\t\tstsfld int64 'program'::'{0}'\n", node.AnchorToken.lexeme);
                }
                 else {
                     Console.WriteLine(node.AnchorToken.lexeme);
                //if(1==1){
                    str = str + Visit((dynamic) node[0], 2)+"\n";
                    str = str +"\t\tstloc '"+node.AnchorToken.lexeme+"'\n";
                    //aqui tengo que arreglarlo para los argumentos
                }
            }
            if(modo == 4){
                 Console.WriteLine("aqui   " + node.AnchorToken.lexeme);
                var argument = "'"+(node.AnchorToken.lexeme)+"'";
                var boolean = false;
                if(args.ContainsKey(currentFunc)){
                    if(args[currentFunc].Contains(argument)){
                        boolean = true;
                    }
                    
                }
                
                 if(boolean){
                     Console.WriteLine("aqui5558");
                     //str = str + node.AnchorToken.lexeme+"\n";
                     str = str + "\t\tldarg '"+node.AnchorToken.lexeme+"'\n";
                }
                else if(localvars.ContainsKey(node.AnchorToken.lexeme))
                {
                    var str2 = "";
                    var i = 0;
                     Console.WriteLine(node.AnchorToken.lexeme+"   klkk");
                    while (i<funcs[node.AnchorToken.lexeme])
                    {
                        str2= str2+"int64";
                        if(funcs[node.AnchorToken.lexeme] > 1 && funcs[node.AnchorToken.lexeme] != i + 1 )
                        {
                            str2 = str2 +",";
                        }   
                    i = i + 1;
                    }
                    
                 foreach (var n in node) {
                    str = str  +Visit((dynamic) n, modo);
                }
                if(apifuncs.Contains(node.AnchorToken.lexeme)){
                    str = str + "\t\tcall int64 class ['int64lib']'Int64'.'Utils'::'"+node.AnchorToken.lexeme+"'("+str2+")\n";
                }
                else{
                    str = str + "\t\tcall int64 class 'program'::'"+node.AnchorToken.lexeme +"'("+str2+")\n";
                }
                return str;
                }
                 else if(global_vars.Contains(node.AnchorToken.lexeme)){
                     Console.WriteLine("aqui5557");
                     str += String.Format("\t\tldsfld int64 'program'::'{0}'\n", node.AnchorToken.lexeme);
                    
                }
                 else if(localvars[currentFunc].Contains(node.AnchorToken.lexeme)){
                     Console.WriteLine(node.AnchorToken.lexeme+"   jnrjnrnnr");
                   Console.WriteLine(node.AnchorToken.lexeme +"rarararararar");
                   str = str + "\t\tldloc '"+node.AnchorToken.lexeme+"'\n";
                }
                
            }
            return str;
        }
        
        public string Visit(Var_def_list_ node, int modo){
              Console.WriteLine("aqui6");
            var str = "";
           if(modo == 1){
               foreach (var n in node[0][0]) {
                    str = str  +"\t\t.locals init (int64 "+Visit((dynamic) n, modo)+")\n";
                }
           }
           return str;
        }
        
        
        public string Visit(Stmt_list_ node, int modo){
              Console.WriteLine("aqui7");
            var str = "";
             foreach (var n in node) {
                    str = str  + Visit((dynamic) n, 2)+"\n";
             }
             return str;
        }
        
        public string Visit(If_ node, int modo){
            
              Console.WriteLine("Entra IF");
            var i = 2;
            var text = "";
            var ExtraLabels = new List<string>();
     
            var condition = Visit((dynamic) node[0],3);
            var thenPart = Visit((dynamic) node[1],3);
             Console.WriteLine("TIENE COND Y THENPART");
            try{
                if(node[2].AnchorToken.lexeme != null && node[2].AnchorToken.lexeme == "else"){
                    Console.WriteLine(node[2].AnchorToken.lexeme);

                    foreach (Node nodo in node[2]){
                        var label = GenerateLabel();
                        ExtraLabels.Add(label);
                        i++;
                    }
                }
            }
            catch (Exception ex) {
                if(ex is System.NullReferenceException || ex is System.ArgumentOutOfRangeException)
                {
                    
                }
                else
                {
                    throw; 
                }
            }
 
             Console.WriteLine("NODOS = " + i);
            var label1 = GenerateLabel();
            lastLabelsStack.Push(label1.ToString());

            for( var n = 0; n < i - 2; n++){
                if(n < i - 3){
                     Console.WriteLine("HIJO IF");
                    var cond = Visit((dynamic) node[2][n][0],3);
                    var thenPartt = Visit((dynamic) node[2][n][1],3);
                     Console.WriteLine("HIJO END");
                    text+= String.Format("\t '{0}':\n{1}\t\tbrfalse '{2}'\n{3}\t\tbr'{4}'\n",
                                        ExtraLabels[n], cond, ExtraLabels[n + 1], thenPartt, label1);
                }
                else{
                      Console.WriteLine("HIJO ELSE");
                    var thenParttt = Visit((dynamic) node[2][n],3);
                    text+= String.Format("\t '{0}':\n {1}", ExtraLabels[n], thenParttt);
                }
            }
            if(i == 2){
                  Console.WriteLine("SOLO HABIA UN IF");
                return String.Format(
                    "{1}\t\tbrfalse '{0}'\n"
                    + "{2}"
                    + "\t\tbr'{0}'\n",
                    label1, condition, thenPart
                );
            }
            else{
                 Console.WriteLine("ENCONTRO MUCHOS ELSE IF");
                return String.Format(
                    "{1}\t\tbrfalse '{0}'\n"
                    + "{2}"
                    + "\t\tbr'{3}'\n"
                    +ExtraLabels[0], condition, thenPart, label1) + text + "\t'"+ label1 +"':\n";
            }
            return "";
        }

      
        public string Visit(Else_ node, int modo){
            var str = "";
            return str;
        }

        public string Visit(Switch_ node, int modo){
              Console.WriteLine("aqui9");
            var a = Visit((dynamic) node[0],3);
            //var cases = new List<string>;
            var ExtraLabels = new List<string>();
            var StmtLabels = new List<string>();
            var defaultExp = Visit((dynamic) node[2],3);
            var text = "";
              Console.WriteLine("switch params done");

            //0 expresion
            //1 casos
            //2 Default + br final
            var count = 0;
            var indexCases = 0;
            var totalCases = 0;
            var indexParams = new List<int>();
            Node magicNode;
            
            foreach (Node nodo in node[1]){
                if(totalCases % 2 == 0){
                    //aqui tenemos un INTEGER
                    if(totalCases > 0){
                        ExtraLabels.Add(GenerateLabel());
                    }
                    totalCases ++;
                }
            }
             Console.WriteLine("Total cases doneeee");
            var str = "";
            foreach (Node nodo in node[1]){
                if(indexCases % 2 == 0){
                    magicNode = nodo;
                      Console.WriteLine("INTEGER");
                    //aqui tenemos un INTEGER
                    if(indexCases > 0){
                        //tenemos que cargar y comparar con el otro Integer de este nodo
                        str+= String.Format("'{0}''{1}'\t\tbeq'{2}'\n'{3}'\t\tbr'{4}'\n", 
                        a, magicNode, ExtraLabels[indexCases], node[1][indexCases + 1], ExtraLabels[totalCases - 1]);
                    }
                    var temp = 1;
                     Console.WriteLine("before checking for kids");
                     Console.WriteLine(magicNode.AnchorToken.Category);
                    while(magicNode.AnchorToken.Lexeme != null && magicNode.AnchorToken.Category == TokenCategory.INTEGER){
                         Console.WriteLine("cheking....");
                        var t = 0;
                        foreach (Node n in magicNode){
                            t++;
                        }
                        if(t < 0){
                            break;
                        }
                        magicNode = nodo[0];
                        temp++;
                    }
                     Console.WriteLine("params = " + temp);
                        
                }
               // else{
                    //aca tenemos un STATEMENT
                    //StmtLabels.Add(GenerateLabel());
                //}
                indexCases ++;
            }

           return text;
        }
        
        public string Visit(Default_ node, int modo){
              Console.WriteLine("aqui10");
             var a = Visit((dynamic) node[0],3);
             return String.Format("'{0}'",a);
        }
        
        public string Visit(Case_ node, int modo){
            return "";
        }
        
        public string Visit(While_ node, int modo){
             Console.WriteLine("aqui11");
            var label1 = "";
            if (lastLabelsStack.Count == 0){
                label1 = GenerateLabel();
                lastLabelsStack.Push(label1);
            }
            else{
                label1 = lastLabelsStack.Peek();
            }
            lastLabelsLoopStack.Push(label1);
            var label2 = GenerateLabel();
            LabelsLoopStack.Push(label2);
            var condition = Visit((dynamic) node[0],3);
            var body = Visit((dynamic) node[1],3);
            
            return String.Format(
                "\t'{0}':\n{1}"
                + "\t\tbrfalse'{2}'\n{3}"
                + "\t\tbr'{0}'\n"
                + "\t'{2}':\n",
                lastLabelsLoopStack.Peek(),condition, label2, body
                //dice que add y push no existe
            );
            
        }
        
        public string Visit(Do_ node, int modo){
             Console.WriteLine("aqui12");
            //var label1 = GenerateLabel();
            var body = Visit((dynamic) node[0],3);
            var condition = Visit((dynamic) node[1][0]);
            var label1 = lastLabelsStack.Peek();
            var label2 = GenerateLabel();
            firstLabelsLoopStack.Push(label2);

           // lastLabelStack.Push(label2);
            //dice que last label stack no existe
            return String.Format(
                "\t'{0}:'\n{1}{2}"
                + "\t\tbrtrue'{0}'\n"
                + "\t\t'{3}':\n",
                label1, body, condition, label2
            );
        }
        
    
         public string Visit(For_ node, int modo){
             //THIS SHIT AINT GONNA HAPPEN
             return null;
        }
        
        public string Visit(Break_ node, int modo){
            return String.Format("\t\tbr {0}\n", LabelsLoopStack.Peek());
        }
        
         public string Visit(Continue_ node, int modo){
            return String.Format("\t\tbr {0}\n", firstLabelsLoopStack.Peek());
        }
        
         public string Visit(Return_ node, int modo){
            return "\t\t"+Visit((dynamic) node[0], 4)+"\n";
        }
        
        public string Visit(Empty_ node, int modo){
             return null;
        }
        
        public string Visit(Expr_list_ node, int modo){
             Console.WriteLine("aqui13");
            var str = "";
            foreach (var n in node) {
                    str = str  +Visit((dynamic) n, 4)+"\n";
             }
            return str;
        }
        
         public string Visit(Expr_ node, int modo){
             return Visit((dynamic) node[0], 4);
        }
 
        
        public string Visit(False_ node, int modo){
            return "\t\tldc.i8 0\n";

        }
        
        public string Visit(True_ node, int modo){
            return "\t\tldc.i8 1\n";

        }
        
        public string Visit(Character_ node, int modo){
                string s = node.AnchorToken.lexeme;
             int n = 0;
             string str = s;
             // Console.WriteLine(s);
             // Console.WriteLine("'\\\"'");
             if (s == "'\\n'"){
                 n = 10;
             }
             else if (s == "'\\r'"){
                 n = 13;
             }
             else if (s == "'\\t'"){
                 n = 9;
             }
             else if (s == "'\\'"){
                 n = 92;
             }
             else if (s == "'\\''"){
                 n = 10;
             }
             else if (s =="'\\\"'"){
                 n = 34;
             }
             else if(s.Length == 10){
                 // Console.WriteLine(str+ "aqui");
                 s = str.Substring(3,6);
                 //str = s.Substring(1,9);
                 // Console.WriteLine(s+ " aqui");
                 n = int.Parse(s, System.Globalization.NumberStyles.HexNumber);;
             }
             else{
                 n = GetUnicodeCodePoints(s);
                 // Console.WriteLine(n+" aqui");
             }
             // Console.WriteLine(node.AnchorToken.row);

           if (modo != 7)
            {
                return "\t\tldc.i8 "+n.ToString()+"\n";
            }
            else {
                try{
                    return n.ToString() + " "+Visit((dynamic) node[0], 7);
                }
                catch(System.ArgumentOutOfRangeException e){
                    return n.ToString();
                }
                return n.ToString();
            }
        }
        
         public string Visit(Integer_ node, int modo){
            if (modo != 7)
            {
                return "\t\tldc.i8 "+node.AnchorToken.lexeme+"\n";
            }
            else {
                try{
                    return node.AnchorToken.lexeme + " "+Visit((dynamic) node[0], 7);
                }
                catch(System.ArgumentOutOfRangeException e){
                    return node.AnchorToken.lexeme;
                }
                
            }
            return node.AnchorToken.lexeme;
        }
   /*     
        public void Visit(Lit_list_ node, int modo){
           
        }
        
        public void Visit(Interrogation_ node, int modo){
             
        }
        
        public void Visit(Colon_ node, int modo){
             
        }
        */
         public string Visit(Or_ node, int modo){
            var str = "";
            str = str+Visit((dynamic) node[0], 4)+"\n";
            str = str+Visit((dynamic) node[1], 4)+"\n";
            str = str + "\t\tor\n";
            return str;
        }
        
         public string Visit(And_ node, int modo){
            var str = "";
            str = str+Visit((dynamic) node[0], 4)+"\n";
            str = str+Visit((dynamic) node[1], 4)+"\n";
            str = str + "\t\tand\n";
            return str;
        }
        
         public string Visit(Comp_ node, int modo){
            var str = "";
            str = str + Visit((dynamic) node[0], 4)+"\n";
            str = str + Visit((dynamic) node[1], 4)+"\n";
            str = str + "\t\tceq\n";
            if(node.AnchorToken.lexeme == "!="){
                 str = str + "\t\tldc.i8 1\n";
                 str = str+ "\t\txor\n";
            }
            return str;
        }
        
         public string Visit(Rel_ node, int modo){
             var str = "";
             str = str+Visit((dynamic) node[0], 4)+"\n";
             str = str+Visit((dynamic) node[1], 4)+"\n";
             if(node.AnchorToken.lexeme == ">"){
                  str = str + "\t\tcgt\n";  
             }
             else if(node.AnchorToken.lexeme == "<"){
                 str = str + "\t\tclt\n";
             }
             else if(node.AnchorToken.lexeme == ">="){
                 str = str + "\t\tclt\n";
                 str = str + "\t\tldc.i8 1\n";
                 str = str+ "\t\txor\n";
             }else if(node.AnchorToken.lexeme == "<="){
                 str = str + "\t\tcgt\n"; 
                 str = str + "\t\tldc.i8 1\n";
                 str = str+ "\t\txor\n";
             }
             return str;
        }
        
         public string Visit(Bit_and_ node, int modo){
             var str = "";
             str = str+Visit((dynamic) node[0], 4)+"\n";
             str = str+Visit((dynamic) node[1], 4)+"\n";
             str = str+ "\t\tand\n";
             return str;
             
        }
        
         public string Visit(Bit_or_ node, int modo){
             var str = "";
             str = str+Visit((dynamic) node[0], 4)+"\n";
             str = str+Visit((dynamic) node[1], 4)+"\n";
             str = str+ "\t\tor\n";
             return str;
        }
        
         public string Visit(Bit_shift_ node, int modo){
             var str = "";
             str = str+Visit((dynamic) node[0], 4)+"\n";
             str = str+Visit((dynamic) node[1], 4)+"\n";
             if(node.AnchorToken.lexeme == ">>"){
                 str = str + "\t\tshl\n";
             }
             else  if(node.AnchorToken.lexeme == ">>"){
                 str = str + "\t\tshl\n";
             }
             return str;
        }
       
         public string Visit(Add_ node, int modo){
            var str = "";
            str = str+Visit((dynamic) node[0], 4)+"\n";
            str = str+Visit((dynamic) node[1], 4)+"\n";
            if (node.AnchorToken.lexeme == "+"){
                 str =  str+"\t\tadd\n";
            }
            else if (node.AnchorToken.lexeme == "-"){
                str =   str+"\t\tsub\n";
            }
            return str;
        }
        
         public string Visit(Mul_ node, int modo){
                var str = "";
            str = str+Visit((dynamic) node[0], 4)+"\n";
            str = str+Visit((dynamic) node[1], 4)+"\n";
            if (node.AnchorToken.lexeme == "/"){
                 str = "\t\tdiv\n";
            }
            else if (node.AnchorToken.lexeme == "*"){
                str =   str+"\t\tmul\n";
            }
            else if (node.AnchorToken.lexeme == "%"){
                str =   str+"\t\trem\n";
            }
            return str;
        }
        
         public string Visit(Pow_ node, int modo){
            var str = "";
            str = str+Visit((dynamic) node[0], 4)+"\n";
            str = str+Visit((dynamic) node[1], 4)+"\n";
            return "\t\tcall int64 class [int64lib]Int64.Utils::Pow(int64, int64)\n";
        }
        
         public string Visit(Unary_ node, int modo){
            var str = "";
            str = str+Visit((dynamic) node[0], 4)+"\n";
            str = str+Visit((dynamic) node[1], 4)+"\n";
            if (node.AnchorToken.lexeme == "+"){
                 str =  str+"\t\tadd\n";
            }
            else if (node.AnchorToken.lexeme == "-"){
                str =   str+"\t\tsub\n";
            }
            return str;
        }
        
        public string Visit(String_ node, int modo){
            Console.WriteLine("aqui10000");
            var str = "";
            Console.WriteLine("aqui100002");
            Console.WriteLine("aqui100002");
            //var litList = Visit((dynamic) node[0]);
            Console.WriteLine("aqui100003");
            var array = GenerateLabel();
            Console.WriteLine("aqui100004");
            str = str + String.Format("\t\t.locals init (int64 '{0}')\n", array);
            Console.WriteLine("aqui100005");
            str = str +"\t\tldc.i8 0\n";
            Console.WriteLine("aqui100006");
            str = str + "\t\tcall int64 class ['int64lib']'Int64'.'Utils'::'New'(int64)\n";
            Console.WriteLine("aqui100007");
            str = str + String.Format("\t\tstloc '{0}'\n", array);
            Console.WriteLine("aqui100008");
            var i = 0;
            Console.WriteLine("aqui100009");
            while(i < node.AnchorToken.lexeme.Length){
                char c = node.AnchorToken.lexeme[i];
                Console.WriteLine("aqui1000010");
                string c1 = c +"" ;
                Console.WriteLine("aqui1000011");
                i++;
                str = str + String.Format("\t\tldloc '{0}'\n", array);
                var n = GetUnicodeCodePoints(c1);
                str = str + String.Format("\t\tldc.i8 {0}\n", n);
                str = str + String.Format("\t\tcall int64 class ['int64lib']'Int64'.'Utils'::'Add'(int64, int64)\n"+"\t\tpop\n");
            }
            str = str + String.Format("\t\tldloc '{0}'\n", array);
            Console.WriteLine(str);
            Console.WriteLine("aqui10001");
            return str;
        }
        
         public string Visit(Openp_ node, int modo){
            return null;
        }
        
         public string Visit(Exclamation_ node, int modo){
            //var compareWith = "\t\tldc.i8 0 \n" +"\t\tceq\n" + "\t\tconv.i8\n";
            //return compareWith;
             return null;
        }
        
         public string Visit(Array_ node, int modo){
            var array = "";
            array = array+Visit((dynamic) node[0],7);
            Console.WriteLine("hola hola "+ array);
            var array1 =  array.Split();
            var stringBuilder = new StringBuilder();
            var variableTempName = GenerateLabel();
            // Add variable to stack
            stringBuilder.Append(String.Format("\t\t.locals init (int64 '{0}')\n", variableTempName));
            // Create array handle
            stringBuilder.Append("\t\tldc.i8 0\n");
            stringBuilder.Append("\t\tcall int64 class ['int64lib']'Int64'.'Utils'::'New'(int64)\n");
            stringBuilder.Append(String.Format("\t\tstloc '{0}'\n", variableTempName));
            // Add values
            foreach(var m in array1){
                stringBuilder.Append(String.Format("\t\tldloc '{0}'\n", variableTempName));
                stringBuilder.Append(String.Format("\t\tldc.i8 {0}\n", m));
                stringBuilder.Append("\t\tcall int64 class ['int64lib']'Int64'.'Utils'::'Add'(int64, int64)\n");
                stringBuilder.Append("\t\tpop\n");
            }
            // Load to top of stack
            stringBuilder.Append(String.Format("\t\tldloc '{0}'\n", variableTempName));
            return stringBuilder.ToString();
        }
       
        public  int GetUnicodeCodePoints(string s){
            int unicodeCodePoint = 0;
            for (int i = 0; i < s.Length; i++){
                unicodeCodePoint = char.ConvertToUtf32(s, i);
                if (unicodeCodePoint > 0xffff){
                    i++;
                }
            }
            return unicodeCodePoint;
        }
        
    }
}
